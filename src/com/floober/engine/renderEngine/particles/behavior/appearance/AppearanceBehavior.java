package com.floober.engine.renderEngine.particles.behavior.appearance;

import com.floober.engine.renderEngine.particles.types.EmitterParticle;
import com.floober.engine.renderEngine.particles.types.LightParticle;
import com.floober.engine.util.math.RandomUtil;
import org.joml.Vector4f;

public abstract class AppearanceBehavior implements Cloneable {

	protected final Vector4f particleColor = new Vector4f(1);
	protected boolean randomColor;
	protected float particleSizeMin, particleSizeMax;

	// methods to override
	public abstract void initParticle(EmitterParticle particle);
	public abstract void updateParticle(EmitterParticle particle);

	public void setParticleColor(EmitterParticle particle) {
		if (randomColor) {
			float r = RandomUtil.getFloat();
			float g = RandomUtil.getFloat();
			float b = RandomUtil.getFloat();
			particle.setColor(r, g, b, particle.getStartAlpha());
		}
		else
			particle.setColor(particleColor);
	}

	/**
	 * Set initial boundary values for the particle size. This
	 * function ignores greater than or less than checks.
	 * @param particleSizeMin The minimum particle size.
	 * @param particleSizeMax The maximum particle size.
	 */
	public void initSize(float particleSizeMin, float particleSizeMax) {
		this.particleSizeMin = particleSizeMin;
		this.particleSizeMax = particleSizeMax;
	}

	// GETTERS

	/**
	 * @return The default particle color.
	 */
	public Vector4f getParticleColor() {
		if (randomColor) return new Vector4f(RandomUtil.getFloat(), RandomUtil.getFloat(), RandomUtil.getFloat(), 1);
		else return particleColor;
	}

	/**
	 * @return The minimum particle size, in pixels at the default resolution.
	 */
	public float getParticleSizeMin() {
		return particleSizeMin;
	}

	/**
	 * @return The maximum particle size, in pixels at the default resolution.
	 */
	public float getParticleSizeMax() {
		return particleSizeMax;
	}

	/**
	 * @return Whether random colors is enabled.
	 */
	public boolean isRandomColor() {
		return randomColor;
	}

	// SETTERS

	/**
	 * Set the minimum size of particles generated by this source.
	 * If the specified size is smaller than 0, or if it is larger
	 * than the current maximum size, this call is ignored.
	 * @param particleSizeMin The minimum particle size, in pixels at the default resolution.
	 */
	public void setParticleSizeMin(float particleSizeMin) {
		if (particleSizeMin > 0 && particleSizeMin <= particleSizeMax)
			this.particleSizeMin = particleSizeMin;
	}

	/**
	 * Set the maximum size of particles generated by this source.
	 * If the specified size is smaller than the current minimum size,
	 * this call is ignored.
	 * @param particleSizeMax The maximum particle size, in pixels at the default resolution.
	 */
	public void setParticleSizeMax(float particleSizeMax) {
		if (particleSizeMax >= particleSizeMin)
			this.particleSizeMax = particleSizeMax;
	}

	/**
	 * Initialize a new particle's size based on the current size settings.
	 * @param particle The particle to initialize.
	 */
	public void setParticleSize(EmitterParticle particle) {
		if (particle instanceof LightParticle) return; // DON'T MESS WITH LIGHT PARTICLES
		float size = RandomUtil.getFloat(particleSizeMin, particleSizeMax);
		particle.setSize(size);
	}

	/**
	 * Set the current default color for particles generated by this source.
	 * When random colors are disabled, all particles generated will be
	 * assigned this color.
	 * @param particleColor The default particle color.
	 */
	public void setParticleColor(Vector4f particleColor) {
		this.particleColor.set(particleColor.x(), particleColor.y(), particleColor.z(), particleColor.w());
		randomColor = false;
	}

	/**
	 * Set whether particles are assigned a random color when created.
	 * When set to false, particles will be given the color assigned to
	 * this ParticleSource.
	 * @param randomColor Whether to enable random colors.
	 */
	public void setRandomColor(boolean randomColor) {
		this.randomColor = randomColor;
	}

	public AppearanceBehavior clone() {
		try {
			return (AppearanceBehavior) super.clone();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

}